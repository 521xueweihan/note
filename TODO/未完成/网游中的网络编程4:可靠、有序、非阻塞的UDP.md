## 目录


# 四、可靠、有序、避免阻塞的UDP

## 介绍
[前面的文章]()中，我们已经在UDP上加入的虚拟连接的概念。

现在我们需要UDP上的虚拟连接，变得可靠、有序、避免阻塞。

这将是这个系列文章中最复杂的部分，也是最近接游戏网络编程的底层。那么打起精神，让我们开始吧！

## TCP的问题
正如你熟知的那样：TCP面向连接、可靠、有序、避免阻塞，那么为什么我们要在UDP重新是实现TCP的那么些已有的特性呢？
（下面就该说为什么我们要自己写一个可靠的UDP了）

问题源于：
1. 多人游戏依赖于一个稳定的数据包流，数据包的发送速率为每秒10至30个包（不能丢包，数据的稳定性，避免阻塞）。

2. 只有最新的数据才是有用的数据（延时不能高，数据的实时性）。

因为传输的数据关系到，如玩家输入（操作），每个玩家的角色的位置方向和速度，以及游戏世界中的对象（怪物）的状态。

TCP的问题就在于：他把数据（以字节流形式）的传输，当作可靠，有序的。所以，如果传输过程中，数据包丢失，
TCP就会停下来等待丢失的数据包重发。这样就会中断稳定的数据包流，因为已到达的数据包要等待重发的数据包。
数据包到齐了，需要进行排序，这也是为什么TCP是有序的。（这样延时就高了）

我们需要另外一种不同类型的可靠连接。我们希望以稳定的速度发送数据包，当接收到数据包的时候得到通知。
这样就可以不需要等待重发的数据包，同时可以根据通知（接收到数据包的通知）来决定如何处理丢掉的包
（因为丢失的数据包可能并不是必须的所以就不需要重发，这点由应用层来决定）。

上面说的那些特性，是TCP不能实现的。所以我们需要用UDP自己实现这些特性。

注意，可靠性不是我们唯一要的事情。因为TCP还提供避免阻塞等其他功能（例如：MSS，避免阻塞算法），下面会一一道来的。

## Sequence Numbers(序列号)
现在回到可靠性上。

我们的可靠连接系统目标很简单：我们希望知道那个数据包到达了连接的另一端。

首先我们需要验证数据包。

如果我们加入`packet id`的概念？现在我们给发送的数据包排号，数据包的顺序从0开始每发送一个数据包就加1。
所以，发送的第一个数据包是：数据包0，发送的第100个数据包，就是数据包99。

TCP中也用的是这个方法，在TCP中，这些`packet ids`叫`sequence numbers`（顺序号）。
我们用的方法和TCP的方法一样，所以我们以后称这些为`sequence numbers`（顺序号）。

UDP是不保证数据包的有序性的，接收到的packet id为100的数据包，不一定是第100个发送的数据包。
为了解决这个问题，我们就需要在数据包中加入`sequence numbers`（顺序号）。

在上一篇[建立虚拟连接的文章]()中，我们已经写了简单的数据包头，所以我们只需要在数据包头中，加入`sequence numbers`如下：
```
[uint protocol id]
[unit sequence]
(packet data...)
```
现在，接收数据包的电脑就知道，数据包的发送顺序了（目前为止，protocol id（用来识别连接），sequence numbers（用来排序数据包））。

## Acks(确认字符)
现在我们可以通过序列号，识别数据包。下一步，就是让连接的另一端知道**接收到**哪个数据包。

这个逻辑上很简单，我们只需要记下我们收到的每个数据包的`sequence number`，并将这些`sequence number`发送给发送给它们的计算机。

所以，我们可以在数据包头中加入ack，就像上面加入`sequence number`那样，形式如下：

```
[unit protocol id]
[unit sequence]
[unit ack]
(packet data..)
```

我们一般这么做：

- 每次我们发送数据都加入本地的`sequence number`。

- 当我们接收到数据包，我们得到接收到的数据包的`sequence number`（上面一条说的本地sequence number），
称这个`sequence number`：远程顺序号。如果接收到了新的数据包，就更新远程顺序号。

- 数据包的头组成：本地顺序号是数据包的sequence，远程顺序号是ack。
这只是一个简单的‘确认收到机制’，为了让我们的连接更加可靠，我们需要让确认收到机制更加完善、可靠。

## Reliable Acks(可靠确认字符)
下面我的实现的方法和TCP完全不一样。

因为TCP的‘确认收到达机制’中，ack字符的值为：`sequence number`下一个（顺序号加1），也就是预计将
要接收到的`sequence number`。如果TCP连接中，在接收的数据包中没有ack的值，那么就重发改数据包。
这是我们所不希望的，因为这样就需要等待重发的包。

所以，在我们的确认收到机制中，我们从不重发有`sequence number`数据包，每个数据包就发一次。因为
从不重发数据包，所以在把接收来的数据包组合的时候，必要的时候需要重新对数据包排序。（反正就是不停下来，重发数据包）

因为我们要做的事情和TCP不同，所以我们现在的‘确认收到机制’不够完善，每个数据包需要多个ack。

为了解决这个问题，我们使用经典的策略：冗余ack，来防止数据包的丢失。

```
[uint protocol id]
[uint sequence]
[uint ack]
[uint ack bitfield]
(packet data...)
```
（翻译不下去了，想吐～）


## 参考
```
TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接：

位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)

第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；

第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包；

第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。

完成三次握手，主机A与主机B开始传送数据。



在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据.
```
